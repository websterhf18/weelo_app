acde0ea5e013113e74f794e80f276a5b
"use strict";

var _interopRequireDefault2 = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault2(require("@babel/runtime/regenerator"));

var _slicedToArray2 = _interopRequireDefault2(require("@babel/runtime/helpers/slicedToArray"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = waitFor;
exports.waitForElement = waitForElement;

var React = _interopRequireWildcard(require("react"));

var _act = _interopRequireDefault(require("./act"));

var _errors = require("./helpers/errors");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var DEFAULT_TIMEOUT = 4500;
var DEFAULT_INTERVAL = 50;

function checkReactVersionAtLeast(major, minor) {
  if (React.version === undefined) return false;

  var _React$version$split$ = React.version.split('.').map(Number),
      _React$version$split$2 = (0, _slicedToArray2.default)(_React$version$split$, 2),
      actualMajor = _React$version$split$2[0],
      actualMinor = _React$version$split$2[1];

  return actualMajor > major || actualMajor === major && actualMinor >= minor;
}

function waitForInternal(expectation, options) {
  var _options$timeout, _options$interval;

  var timeout = (_options$timeout = options === null || options === void 0 ? void 0 : options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : DEFAULT_TIMEOUT;
  var interval = (_options$interval = options === null || options === void 0 ? void 0 : options.interval) !== null && _options$interval !== void 0 ? _options$interval : DEFAULT_INTERVAL;
  var startTime = Date.now();
  var stackTraceError = new _errors.ErrorWithStack('STACK_TRACE_ERROR', waitFor);
  return new Promise(function (resolve, reject) {
    var rejectOrRerun = function rejectOrRerun(error) {
      if (Date.now() - startTime >= timeout) {
        (0, _errors.copyStackTrace)(error, stackTraceError);
        reject(error);
        return;
      }

      setTimeout(runExpectation, interval);
    };

    function runExpectation() {
      try {
        var result = expectation();
        resolve(result);
      } catch (error) {
        rejectOrRerun(error);
      }
    }

    setTimeout(runExpectation, 0);
  });
}

function waitFor(expectation, options) {
  var result;
  return _regenerator.default.async(function waitFor$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (checkReactVersionAtLeast(16, 9)) {
            _context2.next = 2;
            break;
          }

          return _context2.abrupt("return", waitForInternal(expectation, options));

        case 2:
          _context2.next = 4;
          return _regenerator.default.awrap((0, _act.default)(function _callee() {
            return _regenerator.default.async(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return _regenerator.default.awrap(waitForInternal(expectation, options));

                  case 2:
                    result = _context.sent;

                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, null, null, null, Promise);
          }));

        case 4:
          return _context2.abrupt("return", result);

        case 5:
        case "end":
          return _context2.stop();
      }
    }
  }, null, null, null, Promise);
}

function waitForElement(expectation) {
  var _timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4500;

  var _interval = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 50;

  (0, _errors.throwRemovedFunctionError)('waitForElement', 'migration-v2#waitfor-api-changes');
  return Promise.reject();
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndhaXRGb3IuanMiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0Iiwid2FpdEZvciIsIndhaXRGb3JFbGVtZW50IiwiUmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9lcnJvcnMiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiV2Vha01hcCIsImNhY2hlIiwiaGFzIiwiZ2V0IiwibmV3T2JqIiwiaGFzUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZGVzYyIsInNldCIsIkRFRkFVTFRfVElNRU9VVCIsIkRFRkFVTFRfSU5URVJWQUwiLCJjaGVja1JlYWN0VmVyc2lvbkF0TGVhc3QiLCJtYWpvciIsIm1pbm9yIiwidmVyc2lvbiIsInVuZGVmaW5lZCIsInNwbGl0IiwibWFwIiwiTnVtYmVyIiwiYWN0dWFsTWFqb3IiLCJhY3R1YWxNaW5vciIsIndhaXRGb3JJbnRlcm5hbCIsImV4cGVjdGF0aW9uIiwib3B0aW9ucyIsIl9vcHRpb25zJHRpbWVvdXQiLCJfb3B0aW9ucyRpbnRlcnZhbCIsInRpbWVvdXQiLCJpbnRlcnZhbCIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJzdGFja1RyYWNlRXJyb3IiLCJFcnJvcldpdGhTdGFjayIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVqZWN0T3JSZXJ1biIsImVycm9yIiwiY29weVN0YWNrVHJhY2UiLCJzZXRUaW1lb3V0IiwicnVuRXhwZWN0YXRpb24iLCJyZXN1bHQiLCJfdGltZW91dCIsIl9pbnRlcnZhbCIsInRocm93UmVtb3ZlZEZ1bmN0aW9uRXJyb3IiXSwibWFwcGluZ3MiOiJBQUFBOzs7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QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUFsQixDQVBSOztBQUFBO0FBQUEsNENBV1NBLE1BWFQ7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBY0EsU0FBU3ZELGNBQVQsQ0FBd0JvQyxXQUF4QixFQUFzRTtBQUFBLE1BQWpDb0IsUUFBaUMsdUVBQXRCLElBQXNCOztBQUFBLE1BQWhCQyxTQUFnQix1RUFBSixFQUFJOztBQUNwRSxHQUFDLEdBQUduRCxPQUFPLENBQUNvRCx5QkFBWixFQUF1QyxnQkFBdkMsRUFBeUQsa0NBQXpEO0FBQ0EsU0FBT1gsT0FBTyxDQUFDRSxNQUFSLEVBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gd2FpdEZvcjtcbmV4cG9ydHMud2FpdEZvckVsZW1lbnQgPSB3YWl0Rm9yRWxlbWVudDtcblxudmFyIFJlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcblxudmFyIF9hY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2FjdFwiKSk7XG5cbnZhciBfZXJyb3JzID0gcmVxdWlyZShcIi4vaGVscGVycy9lcnJvcnNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5jb25zdCBERUZBVUxUX1RJTUVPVVQgPSA0NTAwO1xuY29uc3QgREVGQVVMVF9JTlRFUlZBTCA9IDUwO1xuXG5mdW5jdGlvbiBjaGVja1JlYWN0VmVyc2lvbkF0TGVhc3QobWFqb3IsIG1pbm9yKSB7XG4gIGlmIChSZWFjdC52ZXJzaW9uID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgW2FjdHVhbE1ham9yLCBhY3R1YWxNaW5vcl0gPSBSZWFjdC52ZXJzaW9uLnNwbGl0KCcuJykubWFwKE51bWJlcik7XG4gIHJldHVybiBhY3R1YWxNYWpvciA+IG1ham9yIHx8IGFjdHVhbE1ham9yID09PSBtYWpvciAmJiBhY3R1YWxNaW5vciA+PSBtaW5vcjtcbn1cblxuZnVuY3Rpb24gd2FpdEZvckludGVybmFsKGV4cGVjdGF0aW9uLCBvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyR0aW1lb3V0LCBfb3B0aW9ucyRpbnRlcnZhbDtcblxuICBjb25zdCB0aW1lb3V0ID0gKF9vcHRpb25zJHRpbWVvdXQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGltZW91dCkgIT09IG51bGwgJiYgX29wdGlvbnMkdGltZW91dCAhPT0gdm9pZCAwID8gX29wdGlvbnMkdGltZW91dCA6IERFRkFVTFRfVElNRU9VVDtcbiAgY29uc3QgaW50ZXJ2YWwgPSAoX29wdGlvbnMkaW50ZXJ2YWwgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaW50ZXJ2YWwpICE9PSBudWxsICYmIF9vcHRpb25zJGludGVydmFsICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRpbnRlcnZhbCA6IERFRkFVTFRfSU5URVJWQUw7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7IC8vIEJlaW5nIGFibGUgdG8gZGlzcGxheSBhIHVzZWZ1bCBzdGFjayB0cmFjZSByZXF1aXJlcyBnZW5lcmF0aW5nIGl0IGJlZm9yZSBkb2luZyBhbnl0aGluZyBhc3luY1xuXG4gIGNvbnN0IHN0YWNrVHJhY2VFcnJvciA9IG5ldyBfZXJyb3JzLkVycm9yV2l0aFN0YWNrKCdTVEFDS19UUkFDRV9FUlJPUicsIHdhaXRGb3IpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlamVjdE9yUmVydW4gPSBlcnJvciA9PiB7XG4gICAgICBpZiAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA+PSB0aW1lb3V0KSB7XG4gICAgICAgICgwLCBfZXJyb3JzLmNvcHlTdGFja1RyYWNlKShlcnJvciwgc3RhY2tUcmFjZUVycm9yKTtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZXRUaW1lb3V0KHJ1bkV4cGVjdGF0aW9uLCBpbnRlcnZhbCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJ1bkV4cGVjdGF0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZXhwZWN0YXRpb24oKTtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0T3JSZXJ1bihlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0VGltZW91dChydW5FeHBlY3RhdGlvbiwgMCk7XG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiB3YWl0Rm9yKGV4cGVjdGF0aW9uLCBvcHRpb25zKSB7XG4gIGlmICghY2hlY2tSZWFjdFZlcnNpb25BdExlYXN0KDE2LCA5KSkge1xuICAgIHJldHVybiB3YWl0Rm9ySW50ZXJuYWwoZXhwZWN0YXRpb24sIG9wdGlvbnMpO1xuICB9XG5cbiAgbGV0IHJlc3VsdDsgLy8kRmxvd0ZpeE1lOiBgYWN0YCBoYXMgaW5jb3JyZWN0IGZsb3cgdHlwaW5nXG5cbiAgYXdhaXQgKDAsIF9hY3QuZGVmYXVsdCkoYXN5bmMgKCkgPT4ge1xuICAgIHJlc3VsdCA9IGF3YWl0IHdhaXRGb3JJbnRlcm5hbChleHBlY3RhdGlvbiwgb3B0aW9ucyk7XG4gIH0pOyAvLyRGbG93Rml4TWU6IGVpdGhlciB3ZSBoYXZlIHJlc3VsdCBvciBgd2FpdEZvcmAgdGhyZXcgZXJyb3JcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB3YWl0Rm9yRWxlbWVudChleHBlY3RhdGlvbiwgX3RpbWVvdXQgPSA0NTAwLCBfaW50ZXJ2YWwgPSA1MCkge1xuICAoMCwgX2Vycm9ycy50aHJvd1JlbW92ZWRGdW5jdGlvbkVycm9yKSgnd2FpdEZvckVsZW1lbnQnLCAnbWlncmF0aW9uLXYyI3dhaXRmb3ItYXBpLWNoYW5nZXMnKTtcbiAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG59Il19